# 对等节点 (Peers)
区块链网络主要由一组对等节点（或简称为peers）组成。 对等节点是网络的基本要素，因为他们托管账本和智能合约。 账本不可变地记录智能合约（或链代码）生成的所有交易。 

智能合约和帐本分别用于封装网络中的共享过程和共享信息。对等节点的这些方面使他们成为了解Hyperledger Fabric网络的良好起点。
![](../images/peers-1.png)

区块链网络由对等节点组成，每个对等节点可以保存账本副本和智能合约副本。 在该示例中，网络N由对等节点P1、P2和P3组成，每个对等节点保持它们自己的分布式帐本L1的实例。 P1、P2和P3使用相同的链代码S1来访问其分布式帐本的副本。
可以创建、启动、停止、重新配置甚至删除对等节点。 它们公开了一组API，使管理员和应用程序能够与他们提供的服务进行交互。 我们将在本节中详细了解这些服务。

## 账本与链代码（Ledgers and Chaincode）
Hyperledger Fabric使用一种技术概念实现智能合约，叫作链代码 (只是一段访问账本的代码，用一种支持的编程语言(1.3版本支持python、go、java)编写)。
![](../images/peers-2.png)

对等节点是托管帐本和链代码的.更准确地说，对等节点实际上托管帐本的实例和链代码的实例。可以在单个对等节点上托管许多帐本和链代码。

由于对等节点是托管帐本和链代码的，因此应用程序和管理员必须与对等节点进行交互才能访问这些资源。 这就是为什么对等节点被认为是Hyperledger Fabric网络最基本的构建块。 对等节点首次创建时，它既没有账本，也没有链代码。

## 多账本（Multiple Ledgers）
对等节点能够托管多个帐本，这很有用，因为它允许灵活的系统设计。 最简单的配置是让对等节点管理单个帐本，但对于对等节点来说，在需要时托管两个或多个帐本也绝对合适。
![](../images/peers-3.png)

上图是一个托管多个帐本的对等节点。 对等节点托管一个或多个帐本，每个帐本具有零个或多个适用于它们的链代码。 在这个例子中，我们可以看到对等节点P1托管账本L1和L2。 使用链代码S1访问帐本L1。 另一方面，可以使用链代码S1和S2访问Ledger L2。

尽管对等节点有可能在没有托管任何访问该帐本的链代码的情况下托管帐本实例，但很少有这种方式配置的对等节点。 绝大多数对等节点将至少安装一个链代码和可以查询或更新对等节点的帐本实例。 值得一提的是，无论用户是否安装了外部应用程序使用的链代码，对等节点还具有始终存在的特殊系统链代码。 

## 多链代码（Multiple Chaincodes）
对等节点拥有的账本数量与可以访问该账本的链代码数量之间没有固定的关系。 对等节点可能有许多链代码和许多账本(当所属组织属于不同的通道时或安装了不同的合约)。
![](../images/peers-4.png)

上图是托管多个链代码的对等节点的示例。 每个帐本都可以有许多访问它的链代码。 在这个例子中，我们可以看到对等节点P1托管账本L1和L2，其中L1由链代码S1和S2访问，L2由S1和S3访问。 我们可以看到S1可以访问L1和L2。

## 应用程序与对等节点（Applications and Peers）
帐本查询交互涉及应用程序和对等节点之间的简单三步对话；帐本更新交互涉及更多，需要两个额外的步骤。最重要的是要理解应用程序与对等节点在帐本查询与帐本更新的交易方式中的差异。

应用程序在需要访问帐本和链代码时始终连接到对等节点。 Hyperledger Fabric软件开发工具包（SDK）使程序员易于使用 - API使应用程序能够连接到对等节点，调用链代码以生成交易，并向网络提交交易，这些交易将被排序并提交到分布式帐本，以及在这个过程完成时接收事件。

通过与对等节点连接，应用程序可以执行链代码来查询或更新帐本。帐本查询交易的结果立即返回，而帐本更新涉及应用程序、对等节点和排序节点之间更复杂的交互。
![](../images/peers-6.png)

- 1.A连接P1
- 2.A调用链代码（提案）
    - 2.1. P1为了提案调用S1
    - 2.2.S1生成查询或更新L1的提案响应
- 3.P1返回提案响应
- 4.A向O1请求交易排序
    - 4.1. O1交易发送到P1
    - 4.2.P1用交易区块更新账本
- 5.P1向A发送账本更新事件

对等节点与排序节点一起确保账本与每个对等节点保持同步。在此示例中，应用程序A连接到P1并调用链代码S1来查询或更新帐本L1。 P1调用S1以生成包含查询结果或建议帐本更新的提案响应。应用程序A接收提案响应，对于查询，该过程就已完成。对于更新，A从所有响应构建一个交易，并将其发送给O1进行排序。 O1将来自网络的交易收集到区块中，并将这些区块分发给所有对等节点，包括P1。 P1在申请提交到L1之前验证交易。 L1更新后，P1会生成又A接收的事件，表示完成。

对等节点可以立即将查询结果返回给应用程序，因为满足查询所需的所有信息都在对等节点的帐本本地副本中。对等节点从不咨询其他对等节点以响应来自应用程序的查询。但是，应用程序可以连接到一个或多个对等节点以发出查询；例如，在多个对等节点之间确认结果，或者如果怀疑信息可能已过期，则从另一个对等节点检索更新的结果。在图中，你可以看到帐本查询是一个简单的三步过程。

更新交易以与查询交易相同的方式启动，但还有两个额外步骤。虽然帐本更新应用程序也连接到对等节点以调用链代码，但与帐本查询应用程序不同，单个对等节点此时无法执行帐本更新，因为其他对等节点必须首先同意更改 - 这个过程称为共识。因此，对等节点向应用程序返回已提议更新 - 该对等节点将根据与其他对等节点先前的协议申请更新。第一个额外步骤 - 第四步 - 要求应用程序向整个对等网络发送一组适当的匹配的已提议更新，作为对其各自帐本交易的承诺。这是通过应用程序使用** 排序节点**将交易打包成区块，并将它们分发到整个对等节点的网络来实现的，在应用于每个对等节点的本地副本之前，可以对它们进行验证。由于整个排序处理需要一些时间才能完成（秒级），因此将异步通知应用程序，如步骤5所示。

## 对等节点与通道（Peers and Channels）
了解对等节点如何相互交互，以及通过通道与应用程序进行交互 - 区块链网络中的一组组件可以通过这种机制进行私有交流和交易。

这些组件通常是对等节点，排序节点和应用程序，并且通过加入通道，他们同意协作以共同共享和管理与该通道相关联的同一个帐本的副本。 从概念上讲，你可以将通道视为与朋友群相似（尽管通道成员当然不需要成为朋友！）。 一个人可能有几朋友群，每个群都有他们一起做的活动。 这些群可能是完全独立的（一群相同爱好朋友对比与一群工作朋友），或者他们之间可能存在一些交叉。 然而，每个群都是自己的实体，具有一种“规则”。
![](../images/peers-5.png)

通道允许一组特定的对等节点和应用程序在区块链网络中相互通信。 在此示例中，应用程序A可以使用通道C直接与对等节点P1和P2通信。你可以将通道视为特定应用程序和对等节点之间通信的途径。 （为简单起见，此图中未显示排序节点，但它必须存在于正常运行的网络中。）

我们看到通道的存在方式与对等节点不同 - 将通道视为由物理对等节点集合形成的逻辑结构更为合适。 了解这一点至关重要 - 对等节点提供了访问和管理通道的控制点。

## 对等节点和组织（Peers and Organizations）
区块链网络由一组组织而不是一个组织管理。 对等节点是如何构建这种分布式网络的核心，因为它们由这些组织所拥有，并且是网络的连接点。
![](../images/peers-8.png)

多组织区块链网络中的对等节点。区块链网络由不同组织拥有和贡献的对等节点构建。在此示例中，我们看到有四个组织贡献了八个对等节点组成网络。通道C连接网络N中P1、P3、P5、P7和P8这五个对等节点。这些组织拥有的其他对等节点尚未加入此通道，但通常会加入至少一个其他通道。由特定组织开发的应用程序将连接到自己组织以及不同组织的对等节点。同样，为简单起见，此图中未显示排序节点。

在区块链网络的形成过程中，你可以看到正在发生的事情，这一点非常重要。该网络由为其提供资源的多个组织形成和管理。对等节点是我们在本主题中讨论的资源，但组织提供的资源不仅仅是对等节点。这里有一个原则 - 如果没有组织将其个人资源贡献给集体网络，网络就不存在。此外，网络随着这些合作组织提供的资源而增长和缩小。

你可以看到（除了排序服务之外）没有集中的资源 - 在上面的示例中，如果组织没有贡献他们的对等节点，网络N就不会存在。这反映了这样一个事实，即网络不存在于任何意义，除非并且直到组织贡献形成它的资源。此外，网络不依赖于任何单个组织 - 只要有一个组织仍然存在，它将继续存在，无论其他组织可能来还是去。这是网络分散化的核心所在。

不同组织中的应用程序，可能相同也可能不同。这是因为它完全取决于组织如何处理其对等节点的账本副本。这意味着应用程序和表示逻辑可能因组织而异，即使它们各自的对等节点托管完全相同的帐本数据。

应用程序可以连接到组织中的对等节点，也可以连接到其他组织中的对等节点，具体取决于所需的帐本交互的性质。对于帐本查询交互，应用程序通常连接到自己组织的同级。

## 对等节点与身份（Peers and Identity）

对等节点通过来自特定证书颁发机构的数字证书为其分配身份。 你可以阅读更多有关X.509数字证书如何在本指南的其他地方工作的内容，但是，现在，将数字证书视为一张ID卡，它提供了许多关于对等节点的可验证信息。 管理员从其所属组织为网络中的每个对等节点分配一个数字证书。
![](../images/peers-9.png)

当对等节点连接到通道时，通道的数字证书通过通道MSP识别其拥有的组织。在此示例中，P1和P2具有由CA1发布的身份。通道C根据其通道配置中的策略确定来自CA1的身份应使用ORG1.MSP与Org1相关联。同样，ORG2.MSP将P3和P4识别为Org2的一部分。

每当对等节点使用通道连接到区块链网络时，通道配置中的策略使用对等节点的身份来确定其权限。身份到组织的映射由称为成员服务提供者（MSP）的组件提供 - 它确定如何将对等节点分配给特定组织中的特定角色，从而获得对区块链资源的适当访问。此外，对等节点只能由单个组织拥有，因此与单个MSP相关联。我们将在本节后面详细了解对等节点访问控制，本指南的其他部分有关于MSP和访问控制策略的完整部分。但就目前而言，将MSP视为在区块链网络中提供单个身份与特定组织角色之间的联接。

## 对等节点与排序节点（Peers and Orderers）
们已经看到，对等节点构成了区块链网络的基础，托管账本和链代码，链代码可以通过对等节点连接的应用程序进行查询和更新。但是，应用程序和对等节点之间交互以确保每个对等节点的帐本保持一致的机制由称为排序（orderers）的特殊节点调解，现在我们转向注意这些节点。

更新交易与查询交易完全不同，因为单个对等节点本身不能更新帐本 - 更新需要网络中其他对等节点的同意。对等节点要求网络中的其他对等节点批准帐本更新，然后才能将其应用于对等节点的本地帐本。此过程称为共识，与简单查询相比，需要更长的时间才能完成。但是，当需要批准交易的所有对等节点都这样做，并且交易被提交到帐本时，对等节点将通知其连接的应用程序帐本已更新。你将在本节中更详细地了解对等节点和排序节点如何管理共识流程。

具体而言，想要更新帐本的应用程序涉及一个三阶段过程，这可确保区块链网络中的所有对等节点保持其帐本彼此一致。在第一阶段，应用程序使用一个背书节点的子集，每个节点提供对应用程序的帐本更新建案的背书，但不将建案的更新应用于其帐本副本。在第二阶段，这些单独的背书作为交易收集在一起并打包成区块。在最后阶段，这些区块将被分发回每个对等节点，在每个对等节点都验证每个交易，然后再应用于该对等节点的帐本副本。

正如你将看到的，排序节点是此过程的核心，因此让我们更详细地研究应用程序和对等节点如何使用排序节点生成可以一致应用于分布式可复制帐本的帐本更新。

**阶段1：提案（Phase 1: Proposal）**
交易流程的第1阶段涉及应用程序和一组对等节点之间的交互 - 它不涉及排序节点。 第1阶段仅涉及一个应用程序要求不同组织的背书节点同意所提案的链代码的调用结果。

为了启动阶段1，应用程序生成一个交易提案，并将其发送给每个需要的对等节点以进行背书。 然后，这些背书节点中的每一个使用交易提案独立地执行链代码以生成交易提案响应。 它不会将此更新应用于帐本，而是简单地对其进行签名并将其返回给应用程序。 一旦应用程序收到足够数量的签名提案响应，交易流程的第一阶段就完成了。 让我们更详细地研究这个阶段。

![](../images/peers-10.png)

最初，应用程序选择一组对等节点来生成一组帐本更新的建案。应用程序选择哪些对等节点呢？那么，这取决于背书策略（定义为链代码），该政策定义了在网络接受之前需要认可帐本变更的组织集合。这实际上是达成共识的意思 - 每个重要的组织必须在任何对等节点账本被接受之前认可账本变更的提案。

对等节点通过添加其数字签名并使用其私钥对整个有效负载进行签名来背书提议响应。这种背书随后可用于证明该组织的对等节点产生了特定的响应。在我们的示例中，如果对等节点P1由组织Org1拥有，则背书E1对应于“Org1的对等节点P1已经提供了账本L1上的交易T1的响应R1！”的数字证据。

当应用程序收到来自足够对等节点的签名提案响应时，阶段1结束。我们注意到，对于相同的交易提案，不同的对等节点可以向应用程序返回不同且因此不一致的交易响应。可能只是在不同的对等节点上，在不同状态下的账本生成结果，在这种情况下，应用程序可以简单地请求更新的提案响应。不太可能，但更严重的是，因为链代码是非确定性的，结果可能会有所不同。非确定性是链代码和账本的敌人，如果它发生，则表明提议的交易存在严重问题，因为不一致的结果显然不适用于账本。单个对等节点无法知道其交易结果是非确定性的 - 在检测到非确定性之前，必须将交易响应收集在一起进行比较。 （严格地说，即使这还不够，但我们将此讨论推迟到交易章节，其中详细讨论了非确定性。）

在阶段1结束时，如果应用程序愿意，应用程序可以自由地丢弃不一致的交易响应，从而有效地提前终止交易流程。稍后我们将看到，如果应用程序尝试使用一组不一致的交易响应来更新帐本，它将被拒绝。

**阶段2：包装（Phase 2: Packaging）**
交易工作流程的第二阶段是包装阶段。 排序节点对此过程至关重要 - 它接收来自许多应用程序的包含已背书交易提案响应的交易。 它将每个交易相对于其他交易进行排序，并将批量交易打包成区块，准备好分发回连接到排序节点的所有对等节点，包括原始的背书对等节点。

![](../images/peers-11.png)
排序节点的第一个角色是打包提议的帐本更新。在该示例中，应用程序A1将由E1和E2背书的交易T1发送到排序节点O1。并行地，应用程序A2将由E1背书的交易T2发送到排序节点O1。 O1将来自应用程序A1的交易T1和来自应用程序A2的交易T2与来自网络中的其他应用程序的其他交易一起打包到区块B2中。我们可以看到，在B2中，交易的顺序是T1、T2、T3
、T4、T6、T5 - 这可能不是这些交易到达排序节点的顺序！（此示例显示了非常简化的排序配置。）

排序节点在特定通道上从网络中的许多不同应用程序同时接收提议的帐本更新。它的工作是将这些提议的更新安排到明确定义的序列中，并将它们打包成区块以供后续分发。这些区块将成为区块链的区块！一旦排序节点生成了所需大小的区块，或者在最大经过时间之后，它将被发送到在特定通道上连接到它的所有对等节点。我们将在第3阶段看到如何处理此区块。

值得注意的是，区块中交易的顺序不一定与交易到达排序节点的顺序相同！交易可能按任何顺序打包到一个区块中，而这个序列就成了执行的顺序。重要的是有一个严格的命令，而不是那个命令是什么。

区块内交易的这种严格排序使Hyperledger Fabric与其他区块链略有不同，其他区块链可以将相同的交易打包到多个不同的块中。在Hyperledger Fabric中，这不可能发生 - 由排序节点集合生成的区块被认为是最终，因为一旦交易被写入区块，它在账本中的位置是确定不可变化的。Hyperledger Fabric的最终结果意味着不会发生称为帐本分叉的灾难性事件。一旦交易被捕获到一个区块中，就不能在将来的时间点为该交易重写历史记录。

在一个区块中 - 排序节点不会对交易的价值做出判断，它只是打包它。这是Hyperledger Fabric的一个重要属性 - 所有交易都被编组成严格的顺序 - 交易永远不会丢失或去优先级。

在第2阶段结束时，我们看到排序节点负责收集提议的更新交易，排序它们，将它们打包进去块，准备分发的简单但至关重要的过程。

**阶段3：验证（Phase 3: Validation）**
交易流程的最后阶段涉及从排序节点到对等节点的区块分发和后续验证，这些对等节点可以把交易应用到帐本。具体而言，在每个对等节点中，区块中的每个交易都经过验证，以确保在将其应用到帐本之前始终得到所有相关组织的认可。 保留失败的交易以进行审计，但不会应用于帐本。
![](../images/peers-12.png)

排序节点的第二个角色是将区块分发到对等节点。在该示例中，排序节点O1将区块B2分发给对等节点P1和对等节点P2。对等节点P1处理区块B2，导致在P1上将新区块添加到帐本L1。并行地，对等节点P2处理区块B2，导致在P2上将新区块添加到账本L1。完成此过程，就是已在对等节点P1和P2上持续地更新了帐本L1，并且每个帐本可以通知连接的应用程序已处理该交易。

阶段3开始于排序节点将区块分配给连接到它的所有对等节点。对等节点被连接到通道上的排序节点，这样当生成新区块时，连接到排序节点的所有对等节点将被发送新区块的副本。每个对等节点将独立处理此块，但其方式与通道上的每个其他对等节点完全相同。通过这种方式，我们看到帐本可以保持一致。值得注意的是，不是每个对等节点都需要连接到一个排序节点 - 对等节点可以使用流言协议将区块级联到其他对等节点，这协议也可以独立处理它们。但是让我们把这个讨论留给另一个时间！

收到一个块后，对等节点将按照它在区块中出现的顺序处理每个交易。对于每个交易，每个对等节点将根据生成交易的链代码的背书策略来验证交易是否已被所需组织认可。例如，某些交易可能只需要由单个组织认可，而其他交易可能需要多个认可才能被视为有效。此验证过程验证所有相关组织是否已生成相同的成果或结果。另请注意，此验证与第1阶段中的背书检查不同，在第1阶段，应用程序接收来自背书对等节点的响应，并决定发送交易提案。如果应用程序通过发送错误的交易违反了背书策略，则对等节点仍然能够在阶段3的验证过程中拒绝该交易。

如果交易已正确背书，则对等节点将尝试将其应用于帐本。为此，对等节点必须执行帐本一致性检查，以验证账本的当前状态是否与生成建议更新时帐本的状态兼容。即使交易已得到完全认可，这也并非总是可能的。例如，另一个交易可能已更新帐本中的相同资产，使得交易更新不再有效，因此无法再应用。通过这种方式，每个对等节点的帐本副本在整个网络中保持一致，因为它们每个都遵循相同的验证规则。

在对等节点成功验证每个单独的交易后，它会更新帐本。失败的交易不会应用于帐本，但会将其保留用于审计目的，成功的交易也是如此。这意味着对等节点的区块几乎与从排序节点接收的区块完全相同，除了区块中每个交易的有效或无效指示符。

我们还注意到阶段3不需要运行链代码 - 这仅在阶段1期间做，这很重要。这意味着只需在背书节点上提供链代码，而不是整个区块链网络。这通常是有帮助的，因为它为背书组织保守了链代码的逻辑秘密。这与链代码的输出（交易提案响应）形成对比，链代码的输出与通道中的每个对等节点共享，无论它们是否需要认可交易。这种背书对等节点的专业化旨在帮助实现可伸缩性。

最后，每次将区块提交给对等节点的帐本时，该对等节点都会生成适当的事件。区块事件包括完整区块内容，而区块交易事件仅包括摘要信息，例如块中的每个交易是否已经生证或无效。链代码执行产生的链代码事件也可以在此时发布。应用程序可以注册这些事件类型，以便在它们发生时得到通知。这些通知结束了交易流程的第三个也是最后一个阶段。

总之，阶段3看到由排序节点生成的区块一致地应用到帐本。将交易严格排序到区块中允许每个对等节点验证在区块链网络上一致地应用交易更新。

## 排序节点与共识（Orderers and Consensus）
整个交易流程过程称为共识，因为所有对等节点都已在排序和交易内容上达成协议，这一过程由排序节点调解。 共识是一个多步骤的过程，只有在流程完成时，应用程序才会被通知帐本更新 - 这可能会在不同的对等节点上稍微不同的时间发生。

我们将在未来的排序节点主题中更详细地讨论排序节点，但是现在，将排序节点视为从对等节点的应用程序收集和分发提议的帐本更新，以验证并包含到帐本中。
