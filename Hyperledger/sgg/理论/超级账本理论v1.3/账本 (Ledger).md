# 账本（Ledger）
## 区块链账本（A Blockchain Ledger）
区块链帐本由两个不同但相关的部分组成 - 世界状态和区块链。

首先，有一个世界状态 - 一个数据库，它保存一组账本状态的当前值。世界状态使程序可以轻松获取这些状态的当前值，而不必通过遍历整个交易日志来计算它们。默认情况下，账本状态表示为键值对，但我们稍后会看到Hyperledger Fabric在这方面提供了灵活性。世界状态可以经常变化，因为状态可以创建、更新和删除。

其次，有一个区块链 - 一个记录决定世界状态的所有变化的交易日志。交易在附加到区块链中的区块内收集 - 使你能够了解导致当前世界状态的更改历史记录。区块链数据结构与世界状态非常不同，因为一旦编写，就无法修改。它是一个不可变的区块序列，每个区块都包含一组有序的交易。

![](../images/ledger-1.png)

据实表达的视觉词汇如下：账本L包括区块链B和世界状态W。区块链B确定世界状态W。也表示为：世界状态W源自区块链B。 

考虑在Hyperledger Fabric网络中存在一个逻辑账本是有帮助的。 实际上，网络维护一个帐本的多个副本 - 通过一个名为共识的过程与其他所有副本保持一致。 术语**分布式帐本技术（DLT）**通常与这种帐本相关联 - 这种帐本在逻辑上是单一的，但在整个网络中分布有许多一致的副本。

## 世界状态（World State）
世界状态代表所有帐本状态的当前值。 它非常有用，因为程序通常需要而且总是很容易获得帐本状态的当前值。 你不需要遍历整个区块链来计算任何帐本状态的当前值 - 你只需直接从世界状态获取它。
![](../images/ledger-3.png)

据实表达的视觉词汇如下：有一个帐本状态，key=CAR1，value=Audi。有一个帐本状态，其中key=CAR2且值更复杂{model:BMW,color=red,owner=Jane}。这两个状态的版本都是0。

帐本状态用于记录要通过区块链共享的应用程序信息。上面的例子显示了两辆汽车的帐本状态，CAR1和CAR2。你可以看到状态具有键和值。你的应用程序调用通过简单API访问状态的链代码 - 它们使用状态的key get、**put 和 delete**状态。注意状态值是如何简单（Audi…）或复杂（type:BMW…）。

在物理上，世界状态是作为数据库实现的。这很有意义，因为数据库提供了丰富的运算符集，可以有效地存储和检索状态。稍后我们将看到Hyperledger Fabric可以配置为使用不同的世界状态数据库来满足不同类型的状态值和应用程序所需的访问模式的需求，例如在复杂查询中。

交易捕获对世界状态的更改，正如你所期望的，交易具有生命周期。它们由应用程序创建，最终被提交到帐本区块链。这里详细描述了整个生命周期；但Hyperledger Fabric的关键设计点是，只有一组认可组织签名的交易才会导致对世界状态的更新。如果交易未由足够的背书人签名，那么它将无法通过此有效性检查，并且不会导致对世界状态的更新。

你还会注意到状态具有版本号，并且在上图中，状态CAR1和CAR2处于其起始版本0。每次状态更改时，状态的版本号都会递增。每当状态更新时也会检查它 - 确保它与创建交易时的版本匹配。此检查确保世界状态在创建交易时从相同的预期值更改为相同的预期值。

最后，当首次创建帐本时，世界状态为空。因为任何代表世界状态有效变化的交易都记录在区块链上，这意味着可以随时从区块链重新生成世界状态。这可能非常方便 - 例如，在创建对等节点时自动生成世界状态。此外，如果对等节点异常失败，则可以在接受交易之前在对等节点重启时重新生成世界状态。

## 区块链（Blockchain）
区块链是一个交易日志，结构为互连区块，每个区块包含一系列交易，每个交易代表对世界状态的查询或更新。 其他地方讨论了排序交易的确切机制 - 重要的是区块排序，以及区块内的交易排序是在首次创建区块时建立的。

每个区块的头部包括区块的交易的hash，以及先前区块的头部hash的副本。通过这种方式，账本上的所有交易都按顺序排列并以加密方式链接在一起。这种散列和链接使得帐本数据非常安全。即使托管帐本的一个节点被篡改，它也无法说服所有其他节点它具有“正确”的区块链，因为帐本分布在整个独立节点的网络中。

物理上，区块链总是作为文件实现，与使用数据库的世界状态形成对比。这是一种明智的设计选择，因为区块链数据结构严重偏向于一小组简单操作。附加到区块链的末尾是主要操作，查询是当前一个相对不频繁的操作。
![](../images/ledger-2.png)

据实表达的视觉词汇如下：区块链B包含区块B0、B1、B2、B3。 B0是区块链中的第一个区块，即起源区块。


在上图中，我们可以看到区块 B2具有区块数据 D2，其包含它所有交易：T5、T6、T7。


最重要的是，B2具有区块头 H2，其包含D2中所有交易的加密hash以及来自前一块B1的等效hash。通过这种方式，区块彼此之间有着密不可分和不可变化的联系，术语区块链如此巧妙地录制！


最后，正如你在图中看到的，区块链中的第一个块称为**起源区块**。它是帐本的起点，但它不包含任何用户交易。相反，它包含网络通道初始状态（未显示出）的配置交易。当我们在文档中讨论区块链网络和通道时，我们会更详细地讨论创世块。
## 区块（Blocks）

让我们仔细看看一个区块的结构。 它由三部分组成


### 区块头

此部分包含三个字段，在创建块时写入。


- 区块号：从0（起源块）开始的整数，并且对于附加到区块链的每个新区块增加1。

- 当前区块Hash：当前区块中包含的所有交易的哈希值。

- 上一个区块Hash：区块链中前一个区块的哈希副本。
![](../images/ledger-4.png)

据实表达的视觉词汇如下：区块B2的区块头H2由区块号2、当前区块数据D2的散列CH2和来自前一块（区块号1）的散列PH1的副本组成。

- 区块数据
    本节包含按顺序排列的交易清单。 它是在创建区块时写入的。 这些交易具有丰富但直接的结构，我们将在本主题后面介绍。
- 区块元数据
    此部分包含写入区块的时间，以及区块编写者的证书、公钥和签名。 随后，区块提交者还为每个交易添加了一个有效/无效的指示符，尽管此信息未包含在hash中，因为创建块时才会创建该信息。

### 交易（Transactions）

正如我们所见，交易采集了世界状态的变化。 让我们看一下详细的区块数据结构，它包含一个区块中的交易。
![](../images/ledger-5.png)
据实表达的视觉词汇如下：区块B1的区块数据D1中的交易T4包括交易头H4、交易签名S4、交易提议P4、交易响应R4和背书列表E4。


在上面的示例中，我们可以看到以下字段：

- Header
    该部分（由H4说明）采集有关交易的一些基本元数据 - 例如，相关链代码的名称及其版本。

- Signature

    该部分（由S4说明）包含由客户端应用程序创建的加密签名。此字段用于检查交易详细信息是否未被篡改，因为它需要应用程序的私钥来生成它。

- Proposal 提案

    该字段（由P4说明）将应用程序提供的输入参数编码到链代码，该链代码创建提议的帐本更新。当链代码运行时，该提案提供了一组输入参数，这些参数与当前世界状态一起确定新的世界状态。

- Response

该部分（由R4说明）采集世界状态的前后值，作为读写集（RW集）。它是链代码的输出，如果交易成功验证，它将应用于帐本以更新世界状态。

-  Endorsements背书


如E4所示，这是来自每个所需组织的签名交易响应列表，足以满足背书策略。 你会注意到，虽然交易中只包含一个交易响应，但有多个背书。 这是因为每个背书都有效地编码了其组织的特定交易响应 - 这意味着不需要包含任何不符合足够背书的交易响应，因为它将被拒绝为无效，并且不会更新世界状态。

## 世界状态数据库选项（World State database options）

世界状态在物理上实现为数据库，以提供简单有效的存储和检索帐本状态。正如我们所看到的，帐本状态可以具有简单或复杂的值，为了适应这种情况，世界状态数据库的实现可以变化，从而允许有效地实现这些值。世界状态数据库的选项目前包括LevelDB和CouchDB。


LevelDB是默认的，当帐本状态是简单的键值对时尤其适用。LevelDB数据库与网络节点紧密共存 - 它嵌入在同一操作系统进程中。


当帐本状态结构化为JSON文档时，CouchDB是一个特别合适的选择，因为CouchDB支持丰富的查询和更新业务交易中常见的更丰富的数据类型。在实现方面，CouchDB在单独的操作系统进程中运行，但网络节点和CouchDB实例之间仍然存在1：1的关系。所有这些对于链代码都是不可见的。有关CouchDB的更多信息，请参见CouchDB作为状态数据库。


在LevelDB和CouchDB中，我们看到了Hyperledger Fabric的一个重要方面 - 它是可插拔的。世界状态数据库可以是关系数据存储，或图形存储，或暂存数据库。这为可以有效访问的帐本状态类型提供了极大的灵活性，允许Hyperledger Fabric解决许多不同类型的问题。

![](../images/ledger-1.png)