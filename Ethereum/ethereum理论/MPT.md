# 梅克尔-帕特里夏树 Merkel-Patricia Tree（MPT）
* https://ethfans.org/posts/merkle-patricia-tree-in-detail
## MPT是什么
- Merkel Patricia Tree (MPT)，翻译为梅克尔-帕特里夏树
- MPT 提供了一个基于密码学验证的底层数据结构，用来存储键值对（key-value）关系
- MPT 是完全确定性的，这是指在一颗 MPT 上一组键值对是唯一确定的，相同内容的键可以保证找到同样的值，并且有同样的根哈希（root hash）
- MPT 的插入、查找、删除操作的时间复杂度都是O(log(n))，相对于其它基于复杂比较的树结构（比如红黑树），MPT 更容易理解，也更易于编码实现

## 字典树（Trie）
![](../images/trie.png)
- 字典树（Trie）也称前缀树（prefix tree），属于搜索树，是一种有序的树数据结构
- 字典树用于存储动态的集合或映射，其中的键通常是字符串

##   基数树（Radix Tree）

### 基本介绍

基数树又叫压缩前缀树（compact prefix tree），是一种空间优化后的字典树，其中如果一个节点只有唯一的子节点，那么这个子节点就会与父节点合并存储

![](../images/radix_trie.png)

### 基数树节点

在一个标准的基数树里，每个节点存储的数据如下：
```
[i0, i1, ... in, value]
```
- 这里的 i0,i1,...,in 表示定义好的字母表中的字符，字母表中一共有n+1个字符，这颗树的基数（radix）就是 n+1
- value 表示这个节点中最终存储的值
- 每一个 i0 到 in 的“槽位”，存储的或者是null，或者是指向另一节点的指针
- 用节点的访问路径表示 key，用节点的最末位置存储 value，这就实现了一个基本的键值对存储

### 示例

我们有一个键值对{ “dog”: “puppy” }，现在希望通过键 dog 访问它的值；我们采用16进制的 Hex 字符作为字符集.
- 首先我们将 “dog” 转换成 ASCII 码，这样就得到了字符集中的表示 64 6f 67，这就是树结构中对应的键
- 按照键的字母序，即 6->4->6->f->6->7，构建树中的访问路径
- 从树的根节点（root）出发，首先读取索引值（index）为 6 的插槽中存储的值，以它为键访问到对应的子节点
- 然后取出子节点索引值为 4 的插槽中的值，以它为键访问下一层节点，直到访问完所需要的路径
- 最终访问到的叶子节点，就存储了我们想要查找的值，即“puppy” 
![](../images/redixtree_example.png)

### 基数树的问题

**数据校验**

基数树节点之间的连接方式是指针，一般是用32位或64位的内存地址作为指针的值，比如C语言就是这么做的。但这种直接存地址的方式无法提供对数据内容的校验，而这在区块链这样的分布式系统中非常重要。

**访问效率**

基数树的另一个问题是低效。如果我们只想存一个 bytes32 类型的键值对，访问路径长度就是64（在以太坊定义的 Hex 字符集下）；每一级访问的节点都至少需要存储 16 个字节，这样就需要至少 1k 字节的额外空间，而且每次查找和删除都必须完整地执行 64 次下探访问。




## 梅克尔树（Merkel Tree）
也被称作哈希树（Hash Tree），以数据块的 hash 值作为叶子节点存储值。梅克尔树的非叶子节点存储其子节点内容串联拼接后的 hash 值。

![](../images/merkel_trie.png)


##   帕特里夏树（Patricia Tree）

- 如果一个基数树的“基数”（radix）为2或2的整数次幂，就被称为“帕特里夏树”，有时也直接认为帕特里夏树就是基数树
- 以太坊中采用 Hex 字符作为 key 的字符集，也就是基数为 16 的帕特里夏树
- 以太坊中的树结构，每个节点可以有最多 16 个子节点，再加上 value，所以共有 17 个“插槽”（slot）位置
- 以太坊中的帕特里夏树加入了一些额外的数据结构，主要是为了解决效率问题





##   MPT（Merkel Patricia Tree）
### 基本介绍
- 梅克尔-帕特里夏树是梅克尔树和帕特里夏树的结合
- 以太坊中的实现，对 key 采用 Hex 编码，每个 Hex 字符就是一个 nibble（半字节）
- 遍历路径时对一个节点只访问它的一个 nibble ，大多数节点是一个包含17个元素的数组；其中16个分别以 hex字符作为索引值，存储路径中下一个 nibble 的指针；另一个存储如果路径到此已遍历结束，需要返回的最终值。这样的节点叫做“分支节点”（branch node）
- 分支节点的每个元素存储的是指向下一级节点的指针。与传统做法不同，MPT 是用所指向节点的 hash 来代表这个指针的；每个节点将下个节点的 hash 作为自己存储内容的一部分，这样就实现了 Merkel 树结构，保证了数据校验的有效性

### MPT 节点分类
MPT 中的节点有以下几类：
- 空节点（NULL）
    - 表示空字符串
- 分支节点（branch）
    - 17 个元素的节点，结构为 [ v0 ... v15, vt ]
- 叶子节点（leaf）
    - 拥有两个元素，编码路径 encodedPath 和值 value
- 扩展节点（extension）
    - 拥有两个元素，编码路径 encodedPath 和键 key

### MPT 中数据结构的优化
- 对于64个字符的路径长度，很有可能在某个节点处会发现，下面至少有一段路径没有分叉；这很难避免
- 我们当然可以依然用标准的分支节点来表示，强制要求这个节点必须有完整的16个索引，并给没有用到的那15个位置全部赋空值；但这样有点蠢
- 通过设置“扩展节点”，就可以有效地缩短访问路径，将冗长的层级关系压缩成一个键值对，避免不必要的空间浪费
- 扩展节点（extension node）的内容形式是 [encodedPath, key]，其中 encodedPath 包含了下面不分叉的那部分路径，key 是指向下一个节点的指针（hash，也即在底层db中的存储位置）
- 叶子节点（leaf node）：如果在某节点后就没有了分叉路径，那这是一个叶子节点，它的第二个元素就是自己的 value

![](../images/dog.png)


##   紧凑编码（compact coding）
- 路径压缩的处理相当于实现了压缩前缀树的功能；不过路径表示是 Hex 字符串（nibbles），而存储却是以字节（byte）为单位的，这相当于浪费了一倍的存储空间
- 我们可以采用一种紧凑编码（compact coding）方式，将两个 nibble 整合在一个字节中保存，这就避免了不必要的浪费
- 这里就会带来一个问题：有可能 nibble 总数是一个奇数，而数据总是以字节形式存储的，所以无法区分 nibble 1 和 nibbles 01；这就使我们必须分别处理奇偶两种情况
- 为了区分路径长度的奇偶性，我们在 encodedPath 中引入标识位

## Hex 序列的压缩编码规则
我们在 encodedPath 中，加入一个 nibble 作为前缀，它的后两位用来标识节点类型和路径长度的奇偶性

![](../images/hex.png)

MPT 中还有一个可选的“结束标记”（用T表示），值为 0x10 (十进制的16)，它仅能在路径末尾出现，代表节点是一个最终节点（叶子节点）

如果路径是奇数，就与前缀 nibble 凑成整字节；如果是偶数，则前缀 nibble 后补 0000 构成整字节

**编码示例**
```
> [ 1, 2, 3, 4, 5, ...] 不带结束位，奇路径
'11 23 45' 
> [ 0, 1, 2, 3, 4, 5, ...]  不带结束位，偶路径
'00 01 23 45' 
> [ 0, f, 1, c, b, 8, 10]  带结束位 T 的偶路径
'20 0f 1c b8' 
> [ f, 1, c, b, 8, 10]  带结束位 T 的奇路径
'3f 1c b8'
```
**MPT 树结构示例**

![](../images/mpt.png)

## 以太坊中树结构
1. 以太坊中所有的 merkel 树都是 MPT
2. 在一个区块的头部（block head）中，有三颗 MPT 的树根：
- stateRoot
    - 状态树的树根
- transactionRoot
    - 交易树的树根
- receiptsRoot
    -  收据树的树根

![](../images/hlockheader.png)

## 以太坊中树结构

1. 状态树（state trie）
    - 世界状态树，随时更新；它存储的键值对 (path, value) 可以表示为 (sha3(ethereumAddress), rlp(ethereumAccount) )
    - 这里的 account 是4个元素构成的数组：[nonce, balance, storageRoot, codeHash]
2. 存储树（storage trie）
    - 存储树是保存所有合约数据的地方；每个合约账户都有一个独立隔离的存储空间
3. 交易树（transaction trie）
    - 每个区块都会有单独的交易树；它的路径（path）是 rlp(transactionIndex)，只有在挖矿时才能确定；一旦出块，不再更改
4. 收据树（receipts trie）
    - 每个区块也有自己的收据树；路径也表示为 rlp(transactionIndex)

![](../images/eth_treepng.png)




# MPT 详解
> 区块中只保存交易树、状态树和收据树的根节点哈希值

> 世界状态：在以太坊中，所有账户（包括合约账户、普通账户）的状态数据统称为世界状态；
## MPT 结构设计
> https://ethfans.org/posts/merkle-patricia-tree-in-detail
### 节点分类
MPT树中，树节点可以分为以下四类：

- 空节点

    空节点用来表示空串。

- 分支节点

    * 分支节点用来表示MPT树中所有拥有超过1个孩子节点以上的非叶子节点。其定义如下所示：
    ```
    type fullNode struct {
            Children [17]node // Actual trie node data to encode/decode (needs custom encoder)
            flags    nodeFlag
    }

    // nodeFlag contains caching-related metadata about a node.
    type nodeFlag struct {
        hash  hashNode // cached hash of the node (may be nil)
        gen   uint16   // cache generation counter
        dirty bool     // whether the node has changes that must be written to the database
    }
    ```
    与前缀树相同，MPT同样是把key-value数据项的key编码在树的路径中，但是key的每一个字节值的范围太大（[0-127]），因此在以太坊中，在进行树操作之前，首先会进行一个key编码的转换（下节会详述），将一个字节的高低四位内容分拆成两个字节存储。通过编码转换，key'的每一位的值范围都在[0, 15]内。因此，一个分支节点的孩子至多只有16个。以太坊通过这种方式，减小了每个分支节点的容量，但是在一定程度上增加了树高。

    * 分支节点的孩子列表中，最后一个元素是用来存储自身的内容。
    * 每个分支节点会有一个附带的字段nodeFlag，记录了一些辅助数据
        * 节点哈希：若该字段不为空，则当需要进行哈希计算时，可以跳过计算过程而直接使用上次计算的结果（当节点变脏时，该字段被置空）；
    
        * 脏标志：当一个节点被修改时，该标志位被置为1；
        *  诞生标志：当该节点第一次被载入内存中（或被修改时），会被赋予一个计数值作为诞生标志，该标志会被作为节点驱除的依据，清除内存中“太老”的未被修改的节点，防止占用的内存空间过多；

- 叶子节点

    叶子节点与扩展节点的定义相似，如下所示：
    ```
    type shortNode struct {
            Key   []byte
            Val   node
            flags nodeFlag
    }
    ```
    其中关键的字段为：

    * Key：用来存储属于该节点范围的key；
    * Val：用来存储该节点的内容；
    > 其中Key是MPT树实现树高压缩的关键！
- 扩展节点

### key值编码
在以太坊中，MPT树的key值共有三种不同的编码方式，以满足不同场景的不同需求。

三种编码方式分别为：

- Raw编码（原生的字符）

    Raw编码就是原生的key值，不做任何改变。这种编码方式的key，是MPT对外提供接口的默认编码方式。

- Hex编码（扩展的16进制编码）

    为了减少分支节点孩子的个数，需要将key的编码进行转换，将原key的高低四位分拆成两个字节进行存储。这种转换后的key的编码方式，就是Hex编码。

- Hex-Prefix编码（16进制前缀编码）

    以太坊提出了一种HP编码对存储在数据库中的叶子／扩展节点的key进行编码区分。在将这两类节点持久化到数据库之前，首先会对该节点的key做编码方式的转换，即从Hex编码转换成HP编码。
### 安全的MPT
以上介绍的MPT树，可以用来存储内容为任何长度的key-value数据项。倘若数据项的key长度没有限制时，当树中维护的数据量较大时，仍然会造成整棵树的深度变得越来越深，会造成以下影响：

- 查询一个节点可能会需要许多次IO读取，效率低下；
- 系统易遭受Dos攻击，攻击者可以通过在合约中存储特定的数据，“构造”一棵拥有一条很长路径的树，然后不断地调用SLOAD指令读取该树节点的内容，造成系统执行效率极度下降；
- 所有的key其实是一种明文的形式进行存储；

为了解决以上问题，在以太坊中对MPT再进行了一次封装，对数据项的key进行了一次哈希计算，因此最终作为参数传入到MPT接口的数据项其实是(sha3(key), value)

优势：

- 传入MPT接口的key是固定长度的（32字节），可以避免出现树中出现长度很长的路径；

劣势：

- 每次树操作需要增加一次哈希计算；
- 需要在数据库中存储额外的sha3(key)与key之间的对应关系；
## MPT核心的基本操作
- Get
- Insert
- Delete
- Update
- Commit