# POS
## PoS简介
在PoW中，节点之间通过hash的计算力来竞赛以获取下一个区块的记账权，而在PoS中，块是已经铸造好的(这里没有“挖矿”的概念，所以我们不用这个词来证明股份)，铸造的过程是基于每个节点(Node)愿意作为抵押的令牌(Token)数量。

这些参与抵押的节点被称为验证者(Validator)，**验证者和节点的概念是等同的！**令牌的含义对于不同的区块链平台是不同的，例如，在以太坊中，每个验证者都将Ether作为抵押品。

如果验证者愿意提供更多的令牌作为抵押品，他们就有更大的机会记账下一个区块并获得奖励。你可以把奖励的区块看作是存款利息，你在银行存的钱越多，你每月的利息就会越高。

因此，这种共识机制被称为股权证明PoS。

一个拥有大量令牌的验证者会在创建新块时根据持有的令牌数量获得更高的概率。然而，这与我们在工作量证明中看到的并没有什么不同：比特币矿场变得越来越强大，普通人在自己的电脑上开采多年也未必能获得一个区块。

因此，许多人认为，使用了PoS后，区块的分配将更加民主化，因为任何人都可以在自己的笔记本上参与，而不需要建立一个巨大的采矿平台，他们不需要昂贵的硬件，只需要一定的筹码，就算筹码不多，也有一定概率能获得区块的记账权，希望总是有的。

在实际应用中，PoS和PoW都有自己的优点和缺点，因此以太坊的Casper具有两者混合的特征。
## 实现POS
### 架构
1. 我们将有一个中心化的TCP服务节点，其他节点可以连接该服务器
2. 最新的区块链状态将定期广播到每个节点
3. 每个节点都能提议建立新的区块
4. 基于每个节点的令牌数量，其中一个节点将随机地(以令牌数作为加权值)作为获胜者，并且将该区块添加到区块链中
### 测试结果
下面来运行程序，打开一个终端窗口，通过go run main.go来启动整个TCP程序，如我们所料，首先创建了创始区块genesisBlock。

接着，我们启动并连接一个验证者。打开一个新的终端窗口，通过linux命令nc localhost 9000来连接到之前的TCP服务。然后在命令提示符后输入一个持有的令牌数额，最后再输入一个验证者的脉搏速率BPM。

然后观察第一个窗口（主程序)，可以看到验证者被分配了地址，而且每次有新的验证者加入时，都会打印所有的验证者列表。

稍等片刻，检查下你的新窗口（验证者)，可以看到正在发生的事：我们的程序在花费时间选择胜利者，然后Boom一声，一个胜利者就诞生了！

再稍等一下，boom! 我们看到新的区块链被广播给所有的验证者窗口，包含了胜利者的区块和他的BPM信息。很酷吧！